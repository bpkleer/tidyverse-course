<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>ggplot-grammar.knit</title>
    <meta charset="utf-8" />
    <script src="ggplot-grammar_files/header-attrs-2.11/header-attrs.js"></script>
    <script src="ggplot-grammar_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="ggplot-grammar_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="ggplot-grammar_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"<i class=\"fa fa-times-circle\" style=\"color: #F94144\"><\/i>"})</script>
    <link href="ggplot-grammar_files/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
    <link href="ggplot-grammar_files/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />
    <link rel="stylesheet" href="styles/slides.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: center, title-slide, middle

# Einführung in ggplot-Grammatik

## Daten bändigen &amp; visualisieren

### B. Philipp Kleer

### Methodentage 2021

### 11. Oktober 2021

.social[
   [&lt;svg viewBox="0 0 512 512" style="position:relative;display:inline-block;top:.1em;fill:#EB811B;height:1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M294.75 188.19h-45.92V342h47.47c67.62 0 83.12-51.34 83.12-76.91 0-41.64-26.54-76.9-84.67-76.9zM256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm-80.79 360.76h-29.84v-207.5h29.84zm-14.92-231.14a19.57 19.57 0 1 1 19.57-19.57 19.64 19.64 0 0 1-19.57 19.57zM300 369h-81V161.26h80.6c76.73 0 110.44 54.83 110.44 103.85C410 318.39 368.38 369 300 369z"&gt;&lt;/path&gt;&lt;/svg&gt;](https://orcid.org/0000-0003-1935-387X)   [&lt;svg viewBox="0 0 512 512" style="position:relative;display:inline-block;top:.1em;fill:#EB811B;height:1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M105.2 24.9c-3.1-8.9-15.7-8.9-18.9 0L29.8 199.7h132c-.1 0-56.6-174.8-56.6-174.8zM.9 287.7c-2.6 8 .3 16.9 7.1 22l247.9 184-226.2-294zm160.8-88l94.3 294 94.3-294zm349.4 88l-28.8-88-226.3 294 247.9-184c6.9-5.1 9.7-14 7.2-22zM425.7 24.9c-3.1-8.9-15.7-8.9-18.9 0l-56.6 174.8h132z"&gt;&lt;/path&gt;&lt;/svg&gt;](https://gitlab.com/bpkleer)   [&lt;svg viewBox="0 0 512 512" style="position:relative;display:inline-block;top:.1em;fill:#EB811B;height:1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M496 128v16a8 8 0 0 1-8 8h-24v12c0 6.627-5.373 12-12 12H60c-6.627 0-12-5.373-12-12v-12H24a8 8 0 0 1-8-8v-16a8 8 0 0 1 4.941-7.392l232-88a7.996 7.996 0 0 1 6.118 0l232 88A8 8 0 0 1 496 128zm-24 304H40c-13.255 0-24 10.745-24 24v16a8 8 0 0 0 8 8h464a8 8 0 0 0 8-8v-16c0-13.255-10.745-24-24-24zM96 192v192H60c-6.627 0-12 5.373-12 12v20h416v-20c0-6.627-5.373-12-12-12h-36V192h-64v192h-64V192h-64v192h-64V192H96z"&gt;&lt;/path&gt;&lt;/svg&gt;](https://www.uni-giessen.de/faculties/f03/departments/dps/staff/researchers/kleer?set_language=en)   [&lt;svg viewBox="0 0 448 512" style="position:relative;display:inline-block;top:.1em;fill:#EB811B;height:1em;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M0 32v448h448V32H0zm262.2 334.4c-6.6 3-33.2 6-50-14.2-9.2-10.6-25.3-33.3-42.2-63.6-8.9 0-14.7 0-21.4-.6v46.4c0 23.5 6 21.2 25.8 23.9v8.1c-6.9-.3-23.1-.8-35.6-.8-13.1 0-26.1.6-33.6.8v-8.1c15.5-2.9 22-1.3 22-23.9V225c0-22.6-6.4-21-22-23.9V193c25.8 1 53.1-.6 70.9-.6 31.7 0 55.9 14.4 55.9 45.6 0 21.1-16.7 42.2-39.2 47.5 13.6 24.2 30 45.6 42.2 58.9 7.2 7.8 17.2 14.7 27.2 14.7v7.3zm22.9-135c-23.3 0-32.2-15.7-32.2-32.2V167c0-12.2 8.8-30.4 34-30.4s30.4 17.9 30.4 17.9l-10.7 7.2s-5.5-12.5-19.7-12.5c-7.9 0-19.7 7.3-19.7 19.7v26.8c0 13.4 6.6 23.3 17.9 23.3 14.1 0 21.5-10.9 21.5-26.8h-17.9v-10.7h30.4c0 20.5 4.7 49.9-34 49.9zm-116.5 44.7c-9.4 0-13.6-.3-20-.8v-69.7c6.4-.6 15-.6 22.5-.6 23.3 0 37.2 12.2 37.2 34.5 0 21.9-15 36.6-39.7 36.6z"&gt;&lt;/path&gt;&lt;/svg&gt;](https://www.researchgate.net/profile/Benedikt_Kleer)
]

---

# Starten wir!
Nun tauchen wir in die Welt von **ggplot2** ein. Das Paket ist **das** Grafik-Paket in R. Viele weitere Grafikpakete beruhen auf derselben Grammatik wie **ggplot2**, so dass Kenntnisse dieses Pakets jedem helfen. 

--

Auch hier laden wir zuerst **tidyverse** bzw. installieren es, wenn es noch nicht installiert ist:


```r
# install.packages("tidyverse")
library("tidyverse")

# alternativ: 
# install.packages("ggplot2")
# library("ggplot2")
```

--

Anschließend laden wir den Datensatz `pss` ins *environment*.


```r
pss &lt;- readRDS("../datasets/pss.rds") #oder eigener Pfad, wenn nicht in Cloud
```

---

# ggplot

Wir machen **gplot2** ist sehr umfangreich, wir machen heute einen Einstieg in die Grammatik. Da die Grafiken aber als Layer aufgebaut sind, können mithilfe des Verständnisses der Grafikgrammatik auch aufwendigere Grafiken erstellt werden. 

Einen Überblick, was wir heute machen:

--

1. Balkendiagramme und Grundaufbau von ggplot

--

2. Histogramme

--

3. Scatterplots

--

4. Gruppierungen

---

class: inverse2, mline, center, middle

# Balkendiagramme

---

# Direkte Ausgabe

Ein Balkendiagramm ist ein Plot einer einzelnen kategorialen Variable. Mit der Funktion `ggplot()` kann man direkt einen Plot ausgeben. 

.pull-left-40[

```r
# direkter Output
ggplot(data = pss,
       mapping = aes(x = edu)
       )
```
]

--

.pull-right-60[
&lt;img src="ggplot-grammar_files/figure-html/ggplot1-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]

---

# Objekte speichern
Alternativ (und meist besser) ist es Grafiken in Objekte zu speichern:

--

.pull-left-40[

```r
# oder speichern als Objekt
mfPlot &lt;- ggplot(data = pss,
                 mapping = aes(x = edu)
                 )
mfPlot
```
]

--

.pull-right-60[
&lt;img src="ggplot-grammar_files/figure-html/ggplot2-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]

--

Aber warum sind beide Plots leer?

???

nur die Struktur wurde angegeben, nicht was geplottet werden soll.

---

# ggplot() verstehen

Wir haben nur das Grundgerüst mit der Funktion `ggplot()` übergeben. Diese Funktion beinhaltet immer die Daten (in `data`) und die Struktur des Plots (`mapping`). Ein Balkendiagramm ist eine univariate Darstellung und deshalb übergeben wir nur eine Variable (hier `edu`). 

--

Um nun ein Balkendiagramm aus dem Plot zu machen, benötigen wir einen weiteren Layer, der eben ein Balkendiagramm ausgibt. Dies ist der Zusatz `geom_bar()`.

--

.pull-left-40[

```r
ggplot(data = pss,
       mapping = aes(x = edu)
       ) +
* geom_bar()

# oder:
# mfPlot + 
#   geom_bar()
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar-out-1.png" width="50%" style="display: block; margin: auto;" /&gt;
]
]

---

# Prozente statt Häufigkeiten

Gerade haben wir uns Häufigkeiten ausgeben lassen. Manchmal möchte man lieber Prozente:
.pull-left-40[

```r
ggplot(data = pss, 
       mapping = aes(x = edu, 
*                    y = ..prop..,
*                    group = 1
                     )
       ) + 
  geom_bar()
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar2-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

???

Hinweise zum Code:

1. y: Einstellung Prozente

2. group: Einstellung nur eine Gruppe, sonst wäre jeder Balken 100 %

---

# Nun wirklich Balken

Alternativ können wir das Diagramm auch zu einem tatsächlichen Balkendiagramm machen und die Säulen loswerden:

--

.pull-left-40[

```r
mfPlot +
  geom_bar() +
* coord_flip()
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar3-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Bringen wir Farbe ins Spiel!
In der Regel wollen wir Grafiken ansprechend gestalten, dafür gibt es verschiedene Argumente in `ggplot()`. Die zwei wichtigsten sind `color` und `fill`. Probieren wir es einfach mal der Reihe nach aus. Wir wollen, dass die Balken jetzt jeweils eine andere Farbe haben.

--

.pull-left-40[

```r
eduPlot &lt;- ggplot(pss, 
                  aes(edu, 
*                     color = edu
                      )
                  ) +
  geom_bar()
eduPlot
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar4-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Coloring
`color` macht also hier nur die Randlinie, nicht aber die Fläche der Balken farbig. Mit `fill` können wir das beheben.

--

.pull-left-40[

```r
eduPlot &lt;- ggplot(pss, 
                  aes(edu, 
*                     fill = edu
                      )
                  ) +
  geom_bar()
eduPlot
```
]

.pull-right-60[
&lt;img src="ggplot-grammar_files/figure-html/bar5-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]

---

# Eigene Farbpaletten

Wenn man eigene Farben benennen will, kann man dies in der Unterfunktion `geom_bar()`. Es empfiehlt sich vorab einen Farbvektor zu definieren:

--

.pull-left-40[

```r
cntryCol = c("steelblue", 
              "seagreen", 
              "red4", 
              "orange",
              "pink",
              "lightgray"
             )

ggplot(pss, 
       aes(x = edu, 
           fill = edu
           )
       ) +
*  geom_bar(fill = cntryCol)
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar6-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Eigene Farbpaletten 

Neben dieser Möglichkeit können auch Farbpaletten genutzt werden, die eine beliebige Anzahl an Farben inkludieren. **Wichtig:** Sind in der Farbpalette weniger Farben definiert, gibt es einen Fehler. Es müssen mindestens so viele Farben vorhanden sein, wie die Variable Kategorien hat. Hierzu fügt man einen weiteren Layer `scale_fill_manual()` bzw. `scale_fill_color()` hinzu. 

--

.pull-left-40[

```r
# a colourblind-friendly palettes
cbp1 &lt;- c("#999999", 
          "#E69F00",
          "#56B4E9",
          "#009E73",
          "#F0E442",
          "#0072B2",
          "#D55E00",
          "#CC79A7"
          )

eduPlotCb&lt;- ggplot(pss, 
                   aes(edu, 
                       fill = edu
                       )
                   ) + 
  geom_bar() +
* scale_fill_manual(values = cbp1)

eduPlotCb
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar7-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
] 

---

# Geld sparen

Für einen kostensparenden Druck kann man auch einfach direkt `scale_fill_gray()` nutzen:

--

.pull-left-40[

```r
ggplot(pss, 
       aes(district, 
           fill = district
           )
       ) + 
  geom_bar() +
  scale_fill_grey()
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bar8-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

--

Alternativ kann man auch verschiedene vorgefertigte Farbpaletten nutzen. Dazu muss man oftmals das entsprechenden Paket laden und dann gibt es eine dazugehörige Funktion, die als zusätzlicher Layer festgelegt wird. 

---

# RColorBrewer

Ein solche Paket ist zum Beispiel `RColorBrewer`:

--


```r
# if(!require("RColorBrewer")) install.packages("RColorBrewer")
library("RColorBrewer")

display.brewer.all()
```

--

Die einzelnen Farbpaletten können, dann wie folgt hinzugefügt werden:

```r
eduPlot +
  scale_fill_brewer(palette = "Dark2")
```

---

# RColorBrewer

.center[
&lt;img src="ggplot-grammar_files/figure-html/brewer2-out-1.png" width="50%" style="display: block; margin: auto;" /&gt;
]

---

# Layout: Achsen anpassen

Als nächsten Schritt passen wir die Achsen an, da die Standardeinstellungen dafür meistens nicht schön sind. Hierfür gibt es folgende Funktionen:

--

- `coord_cartesian()` (Achsengrenzen festlegen)

--

- `scale_x_continuous()`/`scale_y_continuous()` (für numerische Vektoren)

--

- `scale_x_discrete()`/`scale_y_discrete()` (für Faktoren oder Character-Variablen)

--

Was ist mit unseren Achsen?

---

 # Layout: y-Achse anpassen

.pull-left[

```r
eduPlot2 &lt;- eduPlot + 
  coord_cartesian(ylim = c(0,
                           1500
                           )
                  ) +
  scale_y_continuous(breaks = seq(0,  
                                  1500,  
                                  100  
                                  )  
                     )
eduPlot2
```
]

--

.pull-right[
&lt;img src="ggplot-grammar_files/figure-html/axes-out-1.png" width="75%" style="display: block; margin: auto;" /&gt;
]

---

# Layout: x-Achse anpassen

Die x-Achse ist kategoriell und daher macht eine metrische Aufteilung keinen Sinn. Mit `scale_x_discrete()` können wir aber die limits festsetzen:

--

.pull-left[

```r
eduPlot3 &lt;- eduPlot2 + 
  scale_x_discrete(limits = c("ES-ISCED I",    
                              "ES-ISCED II",  
                              "ES-ISCED III",   
                              "ES-ISCED IV",  
                              "ES-ISCED V"  
                              )  
                   )

eduPlot3
```
]

.pull-right[
.center[
&lt;img src="ggplot-grammar_files/figure-html/axes2-out-1.png" width="75%" style="display: block; margin: auto;" /&gt;
]
]

--

Was haben wir ausgelassen?

---

# Layout: Titel, Caption, Legende und weitere Infos

Wir können eine Reihe an Achsenbeschriftungen hinzufügen. Dies geschieht am einfachsten über die Funktion `labs()`. Darin gibt es folgende Unterargumente:

--

- `xlab`: x-Achsentitel
- `ylab`: y-Achsentitel
- `title`: Titel
- `caption`: Fußnote/Caption

--


```r
eduPlot4 &lt;- eduPlot3 +
  labs(x = "Education level",  
       y = "Frequency", 
       title = "my first shot at ggplot2",  
       caption = "Data: Panem Social Survey."  
       )  

eduPlot4
```

---

# Layout: Titel, Caption, Legende und weitere Infos

.center[
&lt;img src="ggplot-grammar_files/figure-html/text1-out-1.png" width="50%" style="display: block; margin: auto;" /&gt;
]

Das schaut schon soweit gut aus, jetzt wollen wir nur noch die Legende anpassen, so dass auch dort ein angepasster Titel steht. 

---

# Layout: und wieder coloring

Dies machen wir in der Funktion `scale_fill_manual()`, die wir zuvor schon genutzt haben. Wir überschreiben sozusagen die Angaben:

--
.pull-left[

```r
eduPlot5 &lt;- eduPlot4 +
  scale_fill_manual(values = cbp1, 
                    name = "Education category", 
                    labels = c("sehr niedrig", 
                               "niedrig",  
                               "mittel", 
                               "hoch",
                               "sehr hoch"
                               )
                    )

eduPlot5
```
]

--

.pull-right[
.center[
&lt;img src="ggplot-grammar_files/figure-html/legend1-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

--

Über die Funktion `theme()` können viele Feineinstellungen vorgenommen werden. Diese können wir nicht im einzelnen hier besprechen, aber es kann wirklich jedes Detail eingestellt werden. Mehr dazu machen die Personen, die am Nachmittag nochmal vertieft mit `ggplot` arbeiten. 

---

class: inverse2, mline, center, middle

# Histogramme

---

# Zum nächsten ...

Gehen wir nun über zu Histogrammen. Diese nutzen wir für metrische Variablen. Hierfür nutzen wir den Layer `geom_histogram()`.

--

.pull-left-40[

```r
agePlot &lt;- ggplot(pss,
                  aes(agea)
                  ) + 
  geom_histogram()  

agePlot
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/hist1-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

--

Auch hier können wir ganz einfach Anpassungen von oben übernehmen und den Plot schöner gestalten.

---

# Fine-Tuning Histogram
.pull-left-40[

```r
agePlot2 &lt;- agePlot +
  geom_histogram(color = "lightgray", 
                 fill = "gray"
                 ) + 
  labs(x = "Age in years", 
       y = "Frequency", 
       title = "Histogram of Age (PSS)"
       )

agePlot2
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/hist2-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Dichte 

Oftmals fügen wir auch die Dichte hinzu, um einfacher beurteilen zu können, ob annähernd eine Normalverteilung vorliegt. Hierzu bestimmen wir, dass die y-Achse die Dichte anzeig (`y = ..density..`) und fügen `geom_density()` hinzu. Mit `alpha` stellen wir Durchsichtigkeit ein und mit `fill` die Farbe der Fläche. 

--

.pull-left-40[

```r
ageDensPlot &lt;- ggplot(pss, 
                      aes(agea)
                      ) + 
* geom_histogram(aes(y = ..density..),
                 color = "lightgray", 
                 fill = "gray"
                 ) + 
* geom_density(alpha = 0.2,
*              fill = "lightblue"
*              ) +
  labs(x = "Age in years", 
       y = "Density", 
       title = "Histogram of Age (PSS)"
       )

ageDensPlot
```
]

--
 
.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/hist3-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Anpassungen: Histogramme

`geom_histogram()` wählt automatisch die Breite der `bin` (Säulen), was irreführend sein kann. Hier könnten wir zum Beispiel so einstellen, dass wir so viele `bins` erhalten, wie es auch tatsächliche Alterskategorien gibt. Man kann einfach die Breite der `bins` mit `binwidth()` festlegen. Hier wählen wir den realen Abstand zwischen zwei Einträgen in dem Vektor/Variable (hier 1).

--

.pull-left[

```r
ggplot(pss, 
       aes(agea)
       ) + 
  geom_histogram(aes(y = ..density..), 
                 color = "lightgray", 
                 fill = "gray",
*                binwidth = 1
                 ) + 
  geom_density(alpha = 0.2, 
               fill = "lightblue"
               ) +
  labs(x = "Age in years", 
       y = "Density", 
       title = "Histogram of Age (PSS)"
       )
```
]

--

.pull-right[
.center[
&lt;img src="ggplot-grammar_files/figure-html/hist5-out-1.png" width="75%" style="display: block; margin: auto;" /&gt;
]
]

---

class: inverse2, mline, center, middle

# Scatterplots

---

# Scatterplots

Oftmals wollen wir zwei Variablen darstellen und ihren Zusammenhang. So könnten wir uns zum Beispiel für den Zusammenhang zwischen der Zufriedenheit mit dem demkoratischen System (`stfdem`) und der Zufriedenheit mit der ökonomischen Entwicklung (`stfeco`) anschauen. Dies sind beides Variablen auf pseudometrischen Niveau gemessen, in R aber als numerische Variablen hinterlegt. 

--

Um Scatterplots darzustellen nutzen wir `geom_point()`. Wir geben jetzt zwei Variablen in `aes()` an. Einmal die x-Achsenvariable und dann die y-Achsenvariable.


```r
scatter1 &lt;- ggplot(pss, 
                   aes(stfeco, 
                       stfdem
                       )
                   ) + 
*  geom_point()

scatter1
```

---

# Scatterplots

.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter1-out-1.png" width="40%" style="display: block; margin: auto;" /&gt;
]

--

Warum sehen wir nun so wenige Punkte, obwohl der Datensatz **5000** Fälle hat?

???

Überlappende Datenpunkte `\(\rightarrow\)` Jittern!

---

# Scatterplot: pseudometrische Variablen

Um pseudo-metrische Variablen korrekt darzustellen, benötigen wir `geom_jitter()`, da die Datenpunkte sonst übereinanderlappen. **Wichtig:** Das jittern sollte angegeben werden, damit kein falscher Dateneindruck entsteht!

--

.pull-left[

```r
scatter2 &lt;- ggplot(pss, 
                   aes(stfeco, 
                       stfdem
                       )
                   ) +
*  geom_jitter(width = 0.3,
*              height = 0.3
*              ) +
  labs(x = "Satisfaction with Economy",
       y = "Satisfaction with Democracy",
       caption = "Data jittered."
       )

scatter2
```
]

--

.pull-right[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter2-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Anpassungen: Scatteprlots

Weitergehend können wir mit `alpha` in `geom_jitter()` (oder auch in `geom_point()`) einen besseren Eindruck verstärken. Datenkombinationen die weniger oft vorkommen erscheinen nciht so kräftig:

--

.pull-left-40[

```r
ggplot(pss, 
       aes(stfeco, 
           stfdem
           )
       ) +  
* geom_jitter(alpha = .2,
              col = "blue"
              )
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter3-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Anpassungen: Scatterplots
Als weitere Argumente können sowohl in `geom_jitter()` als auch in `geom_point()` mit `shape` das Erscheinungsbild geändert werden. Das Cheat Sheet findet man [hier](https://github.com/rstudio/cheatsheets/raw/master/data-visualization.pdf).

---

# Gruppierungen
Oftmals möchte man eine Variable oder den Zusammenhang zweier Variablen getrennt nach einer kategoriellen Variable einblicken. Dazu gibt es in `ggplot` verschiedene Möglichkeiten. Ein paar davon werde ich kurz vorstellen:

--

- Balkendiagramm: `fill` / `color` und `facets`

--

- Scatterplots: `shape` und `facets`

---

# Gruppierungen: Balkendiagramme

Wir möchten gerne wissen, wie viele Befragte in den fünf ausgewählten Distrikten weiblich bzw. männlich sind. Dies können wir einfach erhalten, in dem wir in `ggplot()` mit `fill` eine Aufteilung nach Geschlecht hinzufügen. Das funktioniert auch analog mit `color` (nur ist es etwas unübersichtlich bei Balkendiagrammen).

--

.pull-left-40[

```r
barg &lt;- ggplot(pss, 
               aes(district, 
*                  fill = gndr
                   )
               ) +
  geom_bar()

barg
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/bargroup-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# position_dodge()

Will man dies nun etwas übersichtlicher nebeneinander haben, geschieht dies einfach mit dem Argument `position` in `geom_bar()`:

--

.pull-left-40[

```r
barg2 &lt;- ggplot(pss, 
               aes(district, 
                   fill = gndr
                   )
               ) +
* geom_bar(position = position_dodge())

barg2
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/barg2-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]


---

# Alternativ: facets

Alternativ kann man `facets` innerhalb eines **ggplots** erstellen. Dies geht entweder mit `facet_wrap()` oder mit `facet_grid`:

.pull-left-40[

```r
barg2 &lt;- ggplot(pss, 
               aes(district, 
                   fill = gndr
                   )
               ) +
  geom_bar() +
* facet_wrap(vars(gndr))

barg2
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/facet1-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

???

facet_grid() kommt später noch

---

# Gruppierungen: Scatterplots

Bei Scatteprlots kann man auch direkt `facet_wrap`/`facet_grid` benutzen. Wir möchten nun das Scatterplot von vorher nach Distrikten ausgeben lassen. Dazu können wir zuerst den Distrikten verschiedene Formen zuordnen. Dazu geben wir innerhalb von `aes()` einfach an, dass die Form (`shape`) in Abhängigkeit der Variable `district` ausgegeben werden soll.

.pull-left-40[

```r
ggplot(pss, 
       aes(stfeco, 
           stfdem,
*          shape = district
           )
       ) +  
  geom_jitter(alpha = .2, 
              col = "blue"
              )
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter-shapes-out-1.png" width="55%" style="display: block; margin: auto;" /&gt;
]
]

--

Das ist jetzt noch nicht ganz so übersichtlich. 

---

# Anpassungen bei Gruppierungen

Jetzt könnte man noch zusätzlich die Farbe in Abhängigkeit des Distrikts ändern. Dazu nutzt man das `color`-Argument in `aes()` und entfernt es aus `geom_jitter()`. Lässt man das `color`-Argument in `geom_jitter()` bestehen, wird dies als zuletzt definierte Einstellung verwendet und alles bleibt blau.

--

.pull-left-40[

```r
ggplot(pss, 
       aes(stfeco, 
           stfdem,
           shape = district,
           color = district
           )
       ) +  
  geom_jitter(alpha = .2)
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter-color-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Bisheriges Ergebnis

Die Abbildung ist zwar jetzt schön bunt, aber so richtig einen guten Überblick gibt auch diese Darstellung noch nicht. Um das zu erreichen, nutzt man `facets`. Der Unterschied zwischen den zwei möglichen `facets` ist folgender:

--

- Bei `facet_wrap()` wird aus einer eigentlich eindimensionalen Darstellung eine zweidimensionalen Darstellung gemacht und dementsprechend mehrere Abbildungen erstellt. Wenn man zum Beispiel eine kategoriale Variable hat, nach der man die Darstellung splitten möchte, ist `facet_wrap()` die richtige Wahl. Mit den Argumenten `nrow` und `ncol` kann man dazu die Anzahl der Zeilen und Spalten festlegen.

--

- `facet_grid()` dagegen ist zweidimensional. Hier wird ein Grafikpanel anhand von zwei Variablen erstellt, dass alle Kombinationen (auch die ohne Fälle) anzeigt. Dazu wird die Reihenfolge der Variablen auch wie in einer Formel angegeben, erst pro Zeile und dann pro Spalte.

---
# facet_wrap()

.pull-left-40[

```r
ggplot(pss, 
       aes(stfeco, 
           stfdem,
           shape = district,
           color = district
           )
       ) +  
  geom_jitter(alpha = .2) +
  facet_wrap(vars(district))
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter-facetwrap-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# facet_grid()

Wie oben beschrieben wird in `facet_grid()` ein tatsächlicher zweidimensionaler Plot erstellt. Dazu geben wir in der Funktion selbst an, über welche (kategorialen) Variablen der Plot geteilt werden soll. Die erste Variable ist die Trennung über Zeilen und die zweite Variable die Trennung über Spalten. Im Beispiel trennen wir in Zeilen nach Distrikt und in Spalten nach Geschlecht:

--

.pull-left-40[

```r
ggplot(pss, 
       aes(stfeco, 
           stfdem,
           shape = district,
           color = district
           )
       ) +  
  geom_jitter(alpha = .2) +
  facet_grid(district ~ gndr)
```
]

--

.pull-right-60[
.center[
&lt;img src="ggplot-grammar_files/figure-html/scatter-facetgrid-out-1.png" width="60%" style="display: block; margin: auto;" /&gt;
]
]

---

# Was es noch zu entdecken gibt in ggplot2?

--

- Schriftarten bearbeiten bzw. Darstellung des Plots

--

- *missing values* darstellen

--

- Marginal Plots

--

- bivariate Normalverteilungen

--

- Karten bearbeiten

--

- Zusammenfügen von Plots

---

# Lab
Die Übungsaufgaben findet ihr als `task ggplot` in RStudio Cloud.

---

class: inverse2, mline, center, middle

# Das war's!
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"seal": false,
"highlightStyle": "github",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>`\n",
"navigation": {
"scroll": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
